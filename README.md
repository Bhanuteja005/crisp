# ðŸš€ Crisp Interview - AI-Powered Technical Assessment Platform

<div align="center">
  <img src="https://img.shields.io/badge/React-19+-blue.svg" alt="React">
  <img src="https://img.shields.io/badge/TypeScript-5+-blue.svg" alt="TypeScript">
  <img src="https://img.shields.io/badge/Tailwind-3+-blue.svg" alt="Tailwind">
  <img src="https://img.shields.io/badge/Gemini-AI-green.svg" alt="Gemini AI">
  <img src="https://img.shields.io/badge/Redux-Toolkit-purple.svg" alt="Redux">
</div>

## ðŸ“– Overview

Crisp Interview is a cutting-edge AI-powered technical assessment platform that streamlines the interview process with intelligent automation. Built with React and powered by Google's Gemini AI, it provides real-time question generation, automated scoring, and comprehensive candidate evaluation.

## âœ¨ Key Features

### ðŸ¤– AI-Powered Intelligence
- **Dynamic Question Generation**: Uses Gemini 2.5 Pro to create relevant, contextual questions
- **Intelligent Scoring**: AI evaluates answers with detailed feedback and reasoning
- **Smart Summaries**: Generates comprehensive candidate assessments automatically

### ðŸŽ¯ Interview Management
- **Dual Interface**: Synchronized Interviewee and Interviewer views
- **Real-time Timers**: Question-specific time limits with visual indicators
- **Progress Tracking**: Live interview progress with completion status
- **Auto-submission**: Automatic answer submission when time expires

### ðŸ“„ Resume Processing
- **Multi-format Support**: Handles PDF and DOCX files seamlessly
- **Intelligent Parsing**: Extracts contact information and key details
- **Field Validation**: Smart validation with real-time feedback
- **Missing Data Handling**: Prompts for incomplete information

### ðŸ’¾ Data Persistence
- **Session Recovery**: Resume interrupted interviews seamlessly
- **Local Storage**: Secure client-side data persistence
- **State Management**: Redux with persist for reliable state handling
- **Welcome Back Modal**: Smart session restoration promptsct â€” hereâ€™s a **professional, start-to-finish project plan** you can follow in VS Code (with GitHub + Copilot) to build **AI-Powered Interview Assistant (Crisp)**. I break it into clear milestones, deliverables, folder structure, key components, data models, timelines (sprints), implementation notes, testing, deployment, and a video + README checklist so you can deliver fast and clean.

# Project summary (one line)

Build a React app with two synced tabs â€” **Interviewee (chat)** and **Interviewer (dashboard)** â€” with resume upload + parsing, timed interview flow (6 questions), local persistence (restore on reload), scoring & summaries generated by AI, and a dashboard to review candidates.

---

# High-level milestones (7 total)

1. **Project setup & scaffold** â€” repo, toolchain, UI library, state management.
2. **Resume upload & parsing** â€” PDF / DOCX ingestion + field extraction (Name/Email/Phone).
3. **Interviewee chat UI + interview engine** â€” question generation, timers, auto-submit.
4. **Interviewer dashboard** â€” list, details, search, sort.
5. **Persistence & session restore** â€” redux-persist / IndexedDB, "Welcome Back" modal.
6. **AI integration & scoring** â€” question generation, judge answers, final summary.
7. **Polish, testing, deployment, demo video & README**.

---

# Suggested tech stack (opinionated)

* **Frontend**: React (Vite or Create React App). Use TypeScript for safety.
* **State**: Redux Toolkit + redux-persist (or Zustand + localForage if you prefer IndexedDB).
* **UI**: Ant Design or shadcn/ui (Ant Design gives tables/forms out of box). Use Tailwind if using shadcn.
* **Resume parsing**: `pdf-parse` (client) for PDFs, `mammoth` for DOCX; optional: use a lightweight resume-parser lib or call an AI OCR/LLM if accuracy needed.
* **AI services**: OpenAI (or other LLM) for dynamic questions, scoring, summaries. Use local mock fallback for offline testing.
* **Routing**: React Router.
* **Persistence for files**: store parsed fields and base64 or indexedDB blob references (not raw files) for restore.
* **Testing**: Jest + React Testing Library (unit + integration).
* **Deploy**: Vercel or Netlify (Vercel recommended).
* **Video**: record with Loom / OBS, host on YouTube (unlisted) and link in README.

---

# Sprint plan & timeline (4 sprints, adjustable)

(You can do each sprint in ~2â€“5 days depending on time available)

**Sprint 1 â€” Setup & Resume Upload (2â€“3 days)**

* Initialize repo, CI, basic layout, tabs.
* Implement resume upload UI (PDF/DOCX).
* Implement basic parsing + extract fields (Name, Email, Phone).
* Add validation & friendly error handling.

**Sprint 2 â€” Interview Engine + Chat UI (3â€“4 days)**

* Build chat component with question display, input box, answer history.
* Implement question timers (Easy 20s, Medium 60s, Hard 120s).
* Implement auto-submit on timer expiry and next-question flow.
* Implement missing-fields prompts before starting interview.

**Sprint 3 â€” Interviewer Dashboard & Persistence (3â€“4 days)**

* Implement candidate list, sorting, search.
* Candidate detail view with full chat history, per-question AI scores, final summary.
* Implement Redux store and redux-persist (or localForage).
* Implement Welcome Back modal for unfinished sessions.

**Sprint 4 â€” AI Integration, Polish, Tests, Deploy (3â€“4 days)**

* Integrate with LLM for dynamic questions, per-answer scoring, and final summary.
* Add friendly error handling for API failures and fallback mocks.
* Test persistence fully (close tab, reload, resume).
* Prepare README, demo video, deploy, and submit form.

---

# Repo & folder structure (recommended)

```
/crisp-interview
â”œâ”€ public/
â”œâ”€ src/
â”‚  â”œâ”€ api/                 # api wrappers for AI, resume parsing helper
â”‚  â”œâ”€ app/
â”‚  â”‚   â””â”€ store.ts
â”‚  â”œâ”€ features/
â”‚  â”‚   â”œâ”€ interviewee/
â”‚  â”‚   â”‚   â”œâ”€ Chat.tsx
â”‚  â”‚   â”‚   â”œâ”€ ResumeUpload.tsx
â”‚  â”‚   â”‚   â””â”€ interviewSlice.ts
â”‚  â”‚   â””â”€ interviewer/
â”‚  â”‚       â”œâ”€ Dashboard.tsx
â”‚  â”‚       â””â”€ candidateSlice.ts
â”‚  â”œâ”€ components/
â”‚  â”‚   â”œâ”€ Timer.tsx
â”‚  â”‚   â”œâ”€ WelcomeBackModal.tsx
â”‚  â”‚   â””â”€ ResumePreview.tsx
â”‚  â”œâ”€ utils/
â”‚  â”‚   â”œâ”€ resumeParser.ts
â”‚  â”‚   â””â”€ validators.ts
â”‚  â”œâ”€ types/
â”‚  â”‚   â””â”€ index.ts
â”‚  â”œâ”€ routes.tsx
â”‚  â””â”€ main.tsx
â”œâ”€ scripts/
â”œâ”€ README.md
â”œâ”€ package.json
â””â”€ ... 
```

---

# Data models (TypeScript interfaces)

```ts
// src/types/index.ts
export type Difficulty = 'easy' | 'medium' | 'hard';

export interface Candidate {
  id: string;
  name?: string;
  email?: string;
  phone?: string;
  createdAt: string;
  progress: 'not_started' | 'in_progress' | 'completed';
  score?: number; // final
  summary?: string; // AI generated
  questions: InterviewQuestion[]; // full history + scores
  currentQuestionIndex?: number;
  startedAt?: string;
  pausedAt?: string | null;
}

export interface InterviewQuestion {
  id: string;
  text: string;
  difficulty: Difficulty;
  timerSeconds: number;
  answer?: string;
  answerSubmittedAt?: string;
  score?: number; // AI judge score for this answer (0-100)
  autoSubmitted?: boolean;
}
```

---

# Core flows (pseudocode + implementation guidance)

## 1) Resume upload & field extraction

* Candidate uploads file in Interviewee tab.
* If PDF: use `pdf-parse` in browser (or send file to a small serverless function) to extract text.
* If DOCX: use `mammoth` to convert to text.
* Run regex patterns to extract **name, email, phone**:

  * Email: `/[a-zA-Z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}/i`
  * Phone: try `\+?\d{7,15}` with formatting cleanup.
  * Name: fallback â€” parse first lines or ask candidate to confirm name in chat.
* Save parsed fields to store. If any missing, mark `missingFields` and let chat ask them.

**Pseudocode**

```ts
const parsed = parseResume(file);
const { name, email, phone } = extractFields(parsed.text);
if (!name || !email || !phone) {
  // show missing fields flow in chat
}
```

## 2) Missing fields flow

* Before interview start, chat bot asks for any missing fields in natural sentences:

  * "I couldn't find a phone number on your resume. Could you share it now?"
* Candidate replies; validate & store before allowing the first question.

## 3) Interview question generation (AI)

* For production: call LLM to generate questions for role "Full Stack (React/Node)" with prescribed difficulties and one-by-one basis. Or pre-generate the 6 questions up-front.
* Recommendation: generate a question template set:

  * 2 easy (20s), 2 medium (60s), 2 hard (120s).
* For offline/dev: seed the questions array with static examples.

**Prompt example for LLM**

```
Generate one coding/interview question for a Full Stack (React/Node) role.
Difficulty: HARD
Output JSON: { "id": "...", "text": "...", "difficulty": "hard" }
```

## 4) Timers & auto-submit

* `Timer` component accepts seconds.
* When question displays, start countdown. If time hits 0:

  * auto-submit current text (even if empty) with `autoSubmitted=true`, record timestamp, move to next question.
* If candidate submits early, stop timer and move on.

Edge cases:

* If user refreshes or closes mid-question, the timer remaining must be persisted to store (save `questionStartedAt` and calculate remaining on restore).

**Timer persistence approach**

* Save `questionStartedAt` (timestamp) into candidate state.
* Remaining = `timerSeconds - (now - questionStartedAt)`. If <=0 then auto-submit on restore.

## 5) Scoring + final summary

* After each answer, send answer + question prompt to AI with an evaluation prompt that returns numeric score (0â€“100) and short feedback.
* After 6th question, compute final numeric score (weighted average or simple average) and request a short 2â€“4 sentence candidate summary from AI.

**Evaluation prompt idea**

```
You are an expert interviewer. Given the question and the candidate's answer, score 0-100 on technical correctness, brevity reasons, and provide a 1-2 sentence feedback. Output JSON { "score": 78, "feedback": "..." }
```

## 6) Interviewer dashboard

* Display candidates list (sortable by final score, date, progress).
* Clicking candidate opens details: full Q&A, per-question score+feedback, overall summary.
* Search by name/email; sort by score/date.

---

# State management & persistence

* Use **Redux Toolkit** with slices `candidates` and `ui`.
* Persist store with **redux-persist** and localStorage or use **localForage** for larger blobs.
* Persisted keys: candidates, current session progress, AI caches.
* On app load:

  * If thereâ€™s an unfinished candidate (`progress === 'in_progress'` and `currentQuestionIndex < 6`), show **Welcome Back** modal with Resume/Start options.
  * If clicked Resume â†’ restore timers & continue.
  * If Start New or Delete â†’ clear session.

---

# UI/UX wireframe (textual)

**Top nav**: Logo | Tabs: Interviewee | Interviewer

**Interviewee tab**

* Left: Resume upload + preview & parsed fields.
* Center: Chat window with messages (system/question as bot, candidate responses).
* Bottom: input box, submit button, small timer badge; progress progress bar (1/6).
* Modal for missing fields before first question.

**Interviewer tab**

* Top: Search input + sort dropdown.
* Body: Table of candidates (Name, Email, Score, Progress, Date).
* Right / modal: Candidate detail with timeline of Q&A + per-question score & final summary.

---

# Error handling & validations

* Invalid file types: show clear message & instructions.
* Parsing failure: show "Could not parse â€” please upload a PDF with selectable text or paste your contact info manually."
* AI API errors: show friendly message and fallback to local static questions + mark evaluation as "Unavailable â€” API error".
* Timer syncing issues: if restore finds timer expired, auto-submit and move on.

---

# Copilot usage tips (VS Code)

* Use Copilot to write component boilerplate (e.g., `ChatMessage`, `Timer`), tests, and Redux slices.
* Write clear comments / function signatures first, then accept Copilot suggestions.
* For complex prompts (LLM calls), draft the prompt in a `prompts.ts` and use Copilot to transform response parsing (JSON parsing patterns).

---

# Testing checklist

* Unit tests:

  * resume parsing helper (with sample text).
  * timer calculations and persistence.
  * reducer tests (interview slice).
* Integration tests:

  * full interview flow from upload â†’ 6 Qs â†’ final score.
  * reload mid-question â†’ restore and continue.
* Manual QA:

  * Upload DOCX and PDF variations.
  * Test auto-submit at timer expiry.
  * Test Welcome Back modal flow.

---

# Deployment steps (Vercel recommended)

1. Create GitHub repo (public).
2. Add `.env.local` for API keys (OpenAI_KEY) â€” do **not** commit secrets.
3. Push to GitHub.
4. Connect repo to Vercel; set env vars in Vercel dashboard.
5. Build settings: `npm run build` (Vite/CRA default).
6. Test live site and perform smoke tests.

---

# README outline (must-haves)

* Project title, short description.
* Demo GIF / screenshot.
* Live demo link.
* Quick start (clone, install, run locally).
* Environment variables (OPENAI_API_KEY, etc).
* Features & flow (resume upload, timers, dashboard).
* Tech stack & libraries.
* How scoring / AI prompts work (short).
* Known limitations & future improvements.
* Link to demo video + submission form.

---

# Demo video script (2â€“4 minutes)

1. 0:00â€“0:10 â€” Title slide + quick one-line purpose.
2. 0:10â€“0:40 â€” Show Interviewee tab: upload resume, parsed fields auto-filled.
3. 0:40â€“1:40 â€” Run through interview: show timer, answer, auto-submit, progress.
4. 1:40â€“2:10 â€” Show pause/refresh â†’ Welcome Back modal â†’ resume.
5. 2:10â€“2:40 â€” Switch to Interviewer dashboard: candidate list, sort by score, open candidate details (Q/A + per-question AI feedback + final summary).
6. 2:40â€“3:00 â€” Closing: Link to GitHub, live demo, and submission note.

---

# Deliverables checklist (before submission)

* [ ] Public GitHub repo with clear commits.
* [ ] README filled + demo video link.
* [ ] Live demo deployed (Vercel/Netlify).
* [ ] Demo video recorded & linked (2â€“5 min).
* [ ] Tested persistence & Welcome Back flow.
* [ ] Form submission: [https://forms.gle/Yx5HGCQzHFmHF1wM6](https://forms.gle/Yx5HGCQzHFmHF1wM6)

---

# Minimal implementation plan (fast MVP)

If you want the minimal path to a working demo quickly:

* Use static question sets (hardcode 6 Qs) instead of LLM for question generation.
* Use `pdf-parse` + simple regex for parsing.
* Use redux-persist (localStorage) for persistence.
* Implement scoring as basic rubric (length & keywords) or mock AI scoring for now.
* Polish UI and then swap in LLM scoring later.

---

# Future improvements (nice-to-have)

* Add microphone input and speech-to-text for spoken answers.
* Video recording and asynchronous interview upload.
* Add multi-role question templates (frontend/backend/data).
* Multi-candidate bulk upload.
* Real backend to share data across users.

---

# Quick start commands (example)

```bash
# scaffold (Vite + React + TS)
npm create vite@latest crisp-interview -- --template react-ts
cd crisp-interview
npm install
# libs
npm install @reduxjs/toolkit react-redux redux-persist react-router-dom pdf-parse mammoth localforage axios antd
npm run dev
```

---

If you want, I can right now:

* generate the **Redux slice templates** and **Timer component** code,
* or write the **resumeParser.ts** helper with regex & `mammoth`/`pdf-parse` usage,
* or produce the **exact LLM prompts** for question generation and scoring.

Tell me which of those you want next and Iâ€™ll produce detailed code and files ready for Copilot to autocomplete.
